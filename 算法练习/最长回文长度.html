<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //   var longestPalindrome = function (s) {
      //     const newS = s.split('')
      //     let cach = []
      //     let strLength = []
      //     newS.forEach((i) => {
      //       if (!cach.includes(i)) {
      //         cach.push(i)
      //       } else {
      //         cach.push(i)
      //         cach.splice(0, cach.indexOf(i))
      //         if (cach.length > strLength?.length) {
      //           strLength = [...cach]
      //         }
      //       }
      //     })
      //     return strLength.length == 0 ? s.slice(0, 1) : strLength.join('')
      //   }

      var longestPalindrome = function (s) {
        // 思路：从中间开始向两边扩散来判断回文串
        /**
         *
         * @param {*} s
         * @param {*} l 左边界
         * @param {*} r 右边界
         */
        let palindrome = (s, l, r) => {
          while (l >= 0 && r < s.length && s[l] == s[r]) {
            // 向两边展开
            l--
            r++
          }
          // 返回以s[l]和s[r]为中心的最长回文串
          return s.substr(l + 1, r - l - 1)
        }
        let res = ''
        for (let i = 0; i < s.length; i++) {
          // 以s[i]为中心的最长回文串
          let s1 = palindrome(s, i, i)
          // 以s[i]和s[i+1]为中心的最长回文串
          let s2 = palindrome(s, i, i + 1)
          res = res.length > s1.length ? res : s1
          res = res.length > s2.length ? res : s2
        }
        return res
      }

      console.log(longestPalindrome('aba'))
    </script>
  </body>
</html>
